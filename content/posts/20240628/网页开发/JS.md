---
title: "JS"
date: 2024-01-01T16:00:01+08:00
draft: false
tags:
  - 实操部分
  - JS
  - FE
categories:
  - FE
---

# 一、JS 简介

1.JS(Javascript):初始用于处理网页中的**前端验证**（检查是否符合一定规则）

2.ES(ECMAScript)：是 JS**标准**，一般相同，实际上 JS 的含义更大一些

3.JS：包含**ES**（标准）、**DOM**（文档对象模型，提供对象操作网页）、**BOM**（浏览器对象模型，提供对象操作浏览器）

## 1.输出的三个位置

① 控制浏览器弹出一个警告框：

```js
alert()	弹出警告框
```

② 让计算机在页面中输出一个内容

```js
document.write() 可以向body中输出内容
```

③ 向控制台输出一个内容

```js
console.log() 向控制台输出一个内容
```

## 2.js 编写的三个位置

① 行内式：直接把 js 代码编写到标签的属性中

```js
<button onclick="alert('你点我干嘛')">快来点我阿</button>
<a href="javascript:alert('让你点你就点？');">再点我一下</a>
```

② 内部式：把 js 代码编写到<"script">标签中

```js
"<script></>";
```

③ 外部式：把 js 代码编写到 js 文件中，外部导入

```js
"<script src="">"
```

## 3.注释:

单行注释 // 多行注释 /\* \*/

注：

1. 严格**区分大小写**
2. JS 中每一句以**分号(;)结尾**
3. JS 中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化

## 4.字面量与变量

字面量：不可改变，例如 1 2 3 4 5

变量：可改变，使用 var 为变量声明

```js
var a = xxx;
```

## 5.标识符

标识符：自主命名的名称，包含变量名，函数名，属性名

命名规则：

1. 标识符可含有**字母、数字、\_ 、$**

2. 标识符**不能以数字开头**

3. 标识符**不能是 ES 中的关键字或保留字**

4. 标识符一般采用**驼峰命名法**

   ​ -首字母小写，每个单词开头字母大写，其余字母小写

   ​ -helloWorld

5. JS 底层保存标识符时实际是采用的 Unicode 编码

   ​ 所以理论来说，所有**UTF-8**中含有的内容都可以作为标识符

## 6.数据类型

数据类型：字面量的类型，包含**字符串(**String) 、**数值**(Number) 、**布尔值**(Boolean) 、**空值(**Null) 、**未定义**(Undefined) 、**对象**(Object)

前五个属于基本数据类型，Object 属于引用类型

### 字符串(String)

- 在 JS 中用引号，单双都可，但不可混用

- 引号不能嵌套，双(单)引号不能放双(单)引号，

- 转义符

- 在底层字符串是以字符数组的形式保存的

  ```js
   \"    "
   \'    '
   \n    换行
   \t    制表符
   \\    \
  ```

### 数值(Number)

- 在 JS 中所有的数值都是 Number 类型，包括**整数和浮点数**

- JS 可以表示的数字的最大（小）值

  Number.MAX_VALUE 1.79769313448623157E+308

  Number.MIN_VALUE 5e-324 大于 0 的最小值

- 若超过最大值，则返回 **Infinity** 表示正无穷 **-Infinity** 表示负无穷

  使用**typeof**检查也会返回**Number**

- NaN 是一个特殊的数字，表示 Not A Number

  使用**typeof**检查也会返回**Number**

- 在 JS 中整数的运算基本可以保证精确，浮点运算可能得到个不精确的结果，所以千万不要用 JS 进行对精确度要求比较高的运算

### 布尔值(Boolean)

- true 和 false

### 空值(Null)

- null 专门用来表示一个**空的对象**
- 使用 typeof 检查一个 null 值，会返回**object**

### 未定义(Undefined)

- 当**声明一个变量**，但是**不给变量赋值**时，它的值就是 undefined
- 使用 typeof 检查一个 undefined 值，会返回 undefined

## 7.强制类型转换

指将一个数据类型强制转换为其他的数据类型，转化为 String Number Boolean

### String 的转换

方式一：**xxx.toString()方法**

- 调用方法**xxx.yyy()**
- 不影响原变量，会将转换的结果返回
- 注意：null 与 undefined 这两个值**没有 toString()**方法

方式二：String()的方法

- 调用 String()函数，并将被转换的数据作为参数传递给函数
- 使用 String()函数做强制类型时，对**Number 和 Boolean**来说本质就是方法一，对**Null 和 Undefined**来说，null 转化为"null"

### Number 的转换

**方式一:Number()的方法**

**字符串转数值：**

- **纯数字字符串**转为**数值**，**非纯数字字符串**转为**NaN**，**空串和空格**转为**0**

**布尔转数字**

- true 转为 1
- false 转为 0

**null** 转为 0

**undefined** 转为 NaN

**方式二：parseInt() / parseFloat**

- 专用于字符串
- **parseInt()**整数型转换，**parseFloat()**浮点型转换
- parseInt()只可把**字母前的数字部分**提出来转化为 Number
- 布尔，null，undefined 先转为字符串再进行转换
- 其他进制的数字：十六进制(**0x**),八进制(**0**),二进制(**0b**)
- parseInt(x,2/8//10/16)，第二个数字为进制的表示

Boolean 的转换

使用 Boolean()函数

- **数字转为布尔**：除了**0 和 NaN**，都是 True
- **字符串转为布尔**：除了**空串**，都是 True
- **null 和 undefined 转为布尔**：都是 false
- **对象转为布尔**：True

## 8.运算符

### 算术运算符

当对非 Number 类型（加法中**字符串**特例）的值进行运算时，会将这些值转换为 Number 然后再进行运算

任何值与 NaN 做运算都得 NaN

- +：加法运算，字符串**拼串**，任何值与字符串做加法运算，都先转换为字符串，在进行拼串

小技巧：加法做转字符串 字面量加个空串 即字符串

- -：减法运算

- \*：乘法运算

- /：除法运算

- %：取模运算

小技巧：隐式类型转换：一个值 -0 \*1 /1 将其转化为 Number

### 一元运算符

+，-：正负

小技巧：**隐式类型转换：加个" + "，来将其转换为 Number**

### 自增与自减

#### 自增

- 使变量在自身基础上加一

- 在自增以后，原变量的值会立即自增 1

- 自增分两种：**后++(a++) 和 前++(++a)**

  ​ 无论是 a++，还是++a，都会立即使原变量的值自增 1

  ​ 不同的是 a++ 和 ++a 的值不同

  ​ a++的值等于原变量的值（自增前的值）——**先输出后自增**

  ​ ++a 的值等于新值（自增后的值）——**先自增后输出**

#### 自减

- 通过自减可以使变量在自身的基础上减 1

- 自减分成两种：**后--(a--) 和 前--(--a)**

  ​ 无论是 a--，还是--a，都会立即使原变量的值自增 1

  ​ 不同的是 a-- 和 --a 的值不同

  ​ a--是变量的原值（**自减前的值**）

  ​ --a 是变量的新值（**自减以后的值**）

### 逻辑运算符

**! 非**

- 非运算，对布尔值进行**取反**操作
- 双重取反，则为肯定

小技巧：隐式类型转换：**两个"!!"，来将其转化为布尔值**

**&& 与**

- 与运算，一个 false 则为 false，只有两个值为 true，才为 true

- **短路运算**：第一个为 false，则不会看第二个值

- 非布尔值情况：先转换为布尔值，再进行与运算，并返回原值

  ​ **使用短路逻辑，遇到 false，则返回 false 的原值,没遇到就返回最后的值**

**|| 或**

- 或运算，一个 true，则为 true，两个都为 false，才为 false

- 短路运算：第一个为 true，就不会看第二个值

- 非布尔值情况：先转换为布尔值，再进行或运算，并返回原值

  ​ **使用短路思维，遇到 true，则返回 true 的原值，没遇到就返回最后的值**

### 赋值运算符

**=、+=、-=、\*=、/=、%=**

例如：a += 5 即 a = a+5

### 关系运算符(比较运算符)

**< 、> 、>=、<=、==**

- 非数值情况：先转换为数字在比较，若**两侧为字符串，不会转换为数字**，会分别**比较**字符串中字符的**Unicode 编码**，因此若比较两个字符串型的数字，一定要转型
- 任何值与 NaN 做任何比较都是 false
- 比较两个字符串时，比的是字符串的字符编码，**一位一位的比较**，若两位**一样**，则**比较下一位**，所以借用它对英文进行排序，比较中文时没有意义

### 编码

- 在字符串中使用转义字符输入 Unicode 编码（表中为 16 进制）
- \u 四位编码,十六进制，JS
- &#四位编码,十进制，Web

### 相等运算符

**==，!=,===,!==**

**==：**

- 若值类型不同，会进行自动**类型转换**，将其转换为相同的类型然后再比较
- **undefined 衍生自 null**，所以相等，**NaN 不和任何值相等**，包括它本身
- 判断 b 的值是否是 NaN ,可以通过**isNaN()函数**来判断一个值是否是 NaN

**!=：**

- 不相等运算，自动类型转换

**===：**

- 全等，不进行类型转换，类型不同即为 false

**!==:**

- 不全等，不进行类型转换，类型不同即为 true

### 条件运算符（三元运算符）

- 语法：**条件表达式？语句 1:语句 2;**

- 执行流程:

  ​ 条件运算符在执行时，首先对条件表达式进行求值，

  ​ **true，则执行语句 1，false，则执行语句 2**

```js
var a = 30,
  b = 21,
  c = 50;
var max = a > b ? (a > c ? a : c) : b > c ? b : c;
console.log(max);
```

### 运算符的优先级

![image-20231112193640844](https://minio-api.amjacks.cn/hjs/image-20231112193640844.png)

# 二、流程控制语句

## **1.条件判断语句**：

使用条件判断语句可以执行某个语句之前进行判断

如果条件成立才会执行语句，不成立则不执行

### **if 语句：**

#### **语法一：**

```js
if(条件表达式){
    语句…
}
```

- if 语句在执行时，会先对条件表达式进行求值判断

- 如果条件表达式的值为**true**，则**执行**if 后的语句

- 如果条件表达式的值为**false**，则**不会执行**if 后的语句

- if 语句**只能控制紧随**其后的那个语句

  - 将这些语句统一放到**代码块**中，if 语句可以**控制多条语句**
  - if 语句后的代码块不是必须的，**尽量写上**，**即使 if 后只有一条语句**

#### ** 语法二**

```js
if(条件表达式){
	语句…
}else{
	语句…
}
```

**if…else…语句**

- 当该语句执行时，会先对 if 后的条件表达式进行求值判断

  - 如果该值为 true，则执行 if 后的语句
  - 如果该值为 false，则执行 else 后的语句

### **语法三**

```js
if(条件表达式){
	语句…
}else if{
	语句…
}else if{
	语句…
}else{
	语句…
}
```

**if…else if…else 语句**

- 当该语句执行时，会先对 if 后的条件表达式进行求值判断

  - 如果该值为 true，则执行当前语句

  - 如果该值为 false，则继续向下判断

- 如果所有的条件都不满足，则执行最后一个 else 后的语句

- 该语句中，只会有一个代码块被执行，一旦代码块执行了，则直接结束语句

## **2.条件分支语句**

### **switch 语句**

#### 语法：

```js
switch（条件表达式）{
	case 表达式:
		语句…
		break
	case 表达式:
		语句…
		break
    default:
    	语句…
        break
}
```

#### **执行流程:**

- 依次将**case 后的表达式的值**和**switch 后的条件表达式的值**进行全等比较，

- 如果比较结果为**true**,则从**当前 case 处**开始执行代码。
  - 当前 case 后所有代码都会执行，可在 case 后面跟个 break
- 如果比较结果为**false**,则**继续向下**比较

  - 都为 false，则执行**default 后的语句**

  注：switch 语句和 if 语句功能有重复，根据习惯选择

#### 经典例题：区间范围

```js
var score = +prompt("请输入你的分数：");
switch (true) {
  case score >= 60:
    alert("及格");
    break;
  case score < 60:
    alert("不及格");
    break;
  default:
    alert("未知");
    break;
}
```

## 3.循环语句

### while 循环：

#### 语法

```js
while(条件表达式){
	语句…
}
```

#### 执行流程

- 先对条件表达式进行**求值判断**
  - 如果值为 true，则**执行**循环体，
    - 执行完毕，继续**判断**
    - 若为 true，则继续**执行**循环体
    - 若为 false，则**终止**循环

#### 创建一个循环步骤：

1.创初始化一个变量

2.在循环中设置一个条件表达式

3.定义一个更新表达式，每次更新初始化变量

### do-while 循环

#### 语法：

```js
do{
	语句…
}while(条件表达式)
```

#### 执行流程

- do……while 语句在执行时，限制性循环体

  - 执行完毕，对 while 后的条件表达式进行判断
  - 如果结果为 true，则继续执行循环体，执行完毕继续判断
  - 如果结果为 false，则终止循环

  实际上 while 语句与 do-while 语句类似，不同的是 while 是先判断后执行，而 do-while 会先执行后判断

### for 循环

#### 语法

```js
for (初始化表达式; 条件表达式; 更新表达式) {
  语句;
}
```

#### 执行流程

1. 执行初始化表达式，初始化变量

2. 执行条件表达式，判断是否执行循环

   - 如果为 true，则执行**循环语句**——不先执行更新表达式
   - 如果为 false，则终止循环

3. 执行更新表达式，更新表达式执行完毕继续重复条件表达式

   注：for 循环中三个部分都可以省略，也可以写在外部

### break 与 continue

#### break

- break 关键字可以用来推出 switch 或循环语句

  - 不能在 if 语句中使用 break 和 continue
  - break 关键字，会立即终止离他**最近**的那个循环语句

- 可以为循环语句创建一个**labe**l，来**表示当前的循环**

- 语法：

  ```js
  label：虚幻语句

  ```

- 使用 break 语句时，可以在 break 后跟着一个 label，

  - 这样 break 将会**结束指定的**循环，而不是最近的

#### continue

- continue 关键词可以用来**跳过当次循环**
  - 同样 continue 也是默认只会对离他**最近**的循环起作用
- 计时器:**console.time(" ")**需要一个字符串作为参数，这个字符串将作为计时器的标识

​ **console.timeend(" ")**

# 三、对象

## 1.定义：

属于一种复合的数据类型,在对象中可以保存多个不同数据类型的属性

## 2.分类

**① 内建对象**

- 由**ES 标准**中定义的对象，在任何的 ES 的实现中都可以使用
- 比如：Math String Number Boolean Function Object…

**② 宿主对象**

- 由**JS 的运行环境**提供的对象，目前来讲主要指**浏览器**提供的对象
- 比如**BOM DOM**

**③ 自定义变量**

- 由**开发人员**自己创建的对象

## 3.对对象的一些操作

```js
// 创建对象

第一种;
// 使用new关键字调用的函数，是构造函数（是专门用来创建对象的函数）
var obj = new Object();
// 在对象中保存的值为属性，向对象添加属性
// 语法：对象.属性名 = 属性值;
obj.name = "何某";
obj.gender = "男";
obj.age = "18";

第二种;
// 使用对象字面量创建一个对象
// 语法：{属性名:属性值,属性名:属性值……}
// 对象字面量的属性名最好不加引号，若用特殊名字，必须加引号
/* 属性名与属性值时一组一组的名值对结构
   名和值之间使用:连接，多个名值对之间使用,隔开，若一个属性后没有其他属性了就不要写,
*/

var obj = {
  name: "何某",
  gender: "男",
  age: 18,
};
```

**读取 / 修改/ 删除 对象中的属性**

```js
// 读取对象中的属性
// 语法：对象.属性名

// 如果读取对象中没有的属性，不会报错而是会返回undefined
console.log(obj.name);
```

```js
// 修改对象中的属性
// 语法：对象.属性名 = 新值

obj.name = "Jerry";
console.log(obj.name);

第二种;
// 若要使用特殊的属性名，不能采用.的方式来操作，需要用另外一种方式
// 语法： 对象["属性名"] = 属性值

// 读取也需要用这种方式
// 使用[]这种形式去操作属性，更加的灵活
// 在[]中可以直接传递一个变量，这样的变量值是多少就会读取那个属性
obj["123"] = 789;
obj["nihao"] = "你好";
var n = "123";
console.log(object[n]);
```

```js
// 删除对象中的属性
// 语法：delete 对象.属性名

delete obj.name;
console.log(obj.age);
```

```js
/* in 运算符
  -通过该运算符可以检查一个对象是否含有指定的属性
  	  如果有则返回true，没有则返回false
  -语法:
  		"属性名" in 对象
*/
console.log("name" in obj);
```

​

## 4.栈内存与堆内存

1.JS 的变量都是保存到栈内存中的

​ - 基本数据类型的值直接在在栈内存中存储

​ - 值与值之间是独立存在的，修改一个不会影响到其他的变量

2.对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间

- 而变量保存的是对象的内存地址（对象的引用）

- 如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响

  ![image-20231117074227561](https://minio-api.amjacks.cn/hjs/image-20231117074227561.png)

- 当比较两个基本数据类型的值时，就是比较值

- 而比较两个引用数据类型时，它是比较的对象的内存地址

  - 即使两个对象是一模一样的，但内存地址不同，他也会返回 false

  ![image-20231117074310721](https://minio-api.amjacks.cn/hjs/image-20231117074310721.png)

## 5.Math 对象：

### 常用方法

#### abs()

可以计算一个数的绝对值

#### ceil()

可以向上取整

#### floor()

可以向下取整

#### round()

可以四舍五入取整

#### random()

- 可以生成 0-1 之间的随机数
  - 生成一个 0-x 的随机数
    - Math.round(Math.random()\*x)
  - 生成一个 x-y 之间的随机数
    - Math.round(Math.random() \* (y - x) + x)

#### max()

可以取最大值

#### min()

可以取最小值

#### pow(x, y)

返回 x 的 y 次幂

#### sqrt()

返回数的平方根

## 6.包装类

将基本数据类型转换为对象

### String()

- 可以将基本数据类型字符串转换为 String 对象

### Number()

- 可以将基本数据类型数值转换为 Number 对象

### Boolean()

- 可以将基本数据类型布尔值转换为 Boolean 对象

## 7.string 对象方法

### String.fromCharCode()

- 可以根据字符编码去获取字符

### charAt()

- 可以返回字符串中指定位置的字符
- 根据索引获取指定的字符

### charCodeAt()

- 获取指定位置字符的字符编码(Unicode 编码)

### indexof()

- 该方法可以检索一个字符串中是否含有指定内容
- 如果字符串中含有改内容，则会返回其第一次出现的索引

  - 如果没有找到指定的内容，则返回-1

- 可以指定一个第二个参申诉，指定开始查找的位置

### lastIndexOf()

- 该方法的用法和 indexOf()一样
  - 不同的是 indexOf 是从前往后找
  - 而 lastIndexOf 是返回指定元素最后一次出现时所在位置的索引

### concat()

- 可以用来连接两个或多个字符串
- 作用同 + 一样

### slice()

- 可以从字符串中截取指定的内容
- 不会影响原字符串，而是将截取到内容返回
- 参数
  - 第一个，开始位置的索引（包括开始位置）
  - 第二个，结束位置的索引（不包括结束位置）
    - 如果省略第二个参数，会截取到后面所有的
- 也可以传递一个负数作为参数，负数的话将会从后边计算

### split()

- 可以将一个字符串拆分为一个数组
- 参数

  - 需要一个字符串作为参数，将会根据该字符串取拆分数组

### substr()

- 用来截取字符串
- 参数：
  1. 截取开始位置的索引
  2. 截取的长度

### substring()

- 可以用来截取一个字符串，可以 slice()类似

- 参数：

  1. 可以截取位置的索引（包括开始位置）
  2. 结束位置索引（不包括结束位置）

  - 不同的是这个方法不能接受复制作为参数，如果传递一个负值，则默认使用 0
  - 而且自动调整参数位置，若第二个参数比第一个小，则自动交换

#### toUpperCase()

- 将一个字符串转换为大写并返回

### toLowCase()

- 将一个字符串转换为小写并返回

## 8.正则表达式

### 定义：

定义一些字符串的规则，计算机可用正则表达式，来检查一个字符串是否符合规则，获取将字符串中符合规则的内容提取出来

### 创建

```js
// 创建正则表达式的对象
// 语法：
var 变量 = new RegExp("正则表达式", "匹配模式");
// 这个正则表达式用来检查一个字符串是否含有a
var reg = new RegExp("a");

// 使用typeof检查正则对象，会返回object
// 在构造函数中可以传递一个匹配模式作为第二个参数
	i 忽略大小写 g 全局匹配模式
var reg = new RegExp("a", "i");

/* 正则表达式的方法
test()
 - 使用这个方法可以检查一个字符串是否符合正则表达式的规则
 	如果符合返回true，否则返回false
 - 使用量词来设置一个内容出现的次数，量词只对他前边的一个内容起作用，
	 {n} 正好出现n次
	 {m, n} 出现m-n次
	 {m,} m次以上
	 + 至少一次 ，相当于{1,}
	 * 0个或多个，相当于{0,}
	 ? 0个或1个，相当于{0, 1}

	 */

```

```js
// 检查一个字符串中是否以a开头

/* 	 ^ 表示开头 
	 $ 表示结尾 	*/
var result = reg.test(str);
var reg = /a{3}/;
console.log(reg.test("bbb"));

/* 检查一个字符串中是否含有. 
    .表示任意字符
    在正则表达式中使用\作为转义字符
    \. 表示 .
    \\ 表示 \  */
var reg = /\./;
reg = /\\/;
console.log(reg.test("b.\\"));
/*
\w —— 任意字	母、数字、_  [A-z0-9_]
\W —— 除了字母、数字、_  [^A-z0-9_]
\d —— 任意数字 [0-9]
\D —— 除了数字 [^0-9]
\s —— 空格
\S —— 除了空格
\b —— 单词边界
\B —— 除了单词边界
*/
```

```js
// 使用字面量来创建正则表达式
// 语法
var 变量 = /正则表达式/匹配模式;
// 用构造函数创建更加灵活，可以是变量
```

### 符号的应用

- | == [ ] : 为“或”的意思
  - [ab] == a | b
  - [a - z] 任意小写字母
  - [A - Z] 任意大写字母
  - [A - z] 任意字母
- [^ ] : "除了"的意思

### 字符串和正则相关的方法

#### split

- 参数可用正则表达式替代

- 不指定全局匹配，也会全部拆分

#### search

- 搜索是否有指定内容，搜到返回第一次出现的索引，，没检索到返回-1
- 正则表达式作为参数，根据正则表达式去检索
- 即使全局匹配，仍只会返回第一次出现的索引

#### match

- 根据正则表达式，从一个字符串中查找并提取符合的内容
- 默认情况 match 只执行一次，所以需要开启全局匹配

```js
result = str.match(/[a-Z]/gi);
```

#### replace

- 可以将字符串中指定内容替换为新的内容
- 参数
  1. 被替换的内容，可以接收一个正则表达式作为参数
  2. 新的内容
- 默认只会替换第一个，开启全局匹配

# 四、函数

## 1.函数 function：

函数也是一个对象，可以封装一些功能（代码），在需要时可以执行这些功能（代码）

函数中可以保存一些代码在需要时调用

## 2.创建函数对象：

```js
第一种
// 构造函数来创建一个函数对象（少用）
// 可以将要封装的代码以 字符串 的形式传递给构造函数
var fun =  new Function("console.log('Hello 这是我的第一个函数');");

// 封装到函数的代码不会立即执行
// 函数中的代码会在函数调用的时候执行

// 调用函数
// 语法：函数对象()
fun()
// 当调用函数时，函数中封装的代码会按照顺序执行

第二种（更佳）
// 使用函数声明来创建一个函数
/* 语法 : function 函数名([形参1、形参2……形参N]) {
	语句…
}  */
function fun2(){
    console.log("这是我的第二个函数~~~")
}
fun2()

第三种
// 使用函数表达式来创建一个函数
// 本质：创建一个匿名函数赋值给前面的变量————赋值语句
/* var 函数名 = function ([形参1,形参2,……形参N]){
	语句……
} */

```

## 3.参数：

### 形参：

- 可以在**函数的()**中来指定一个或多个形参(形式参数)
- 多个形参之间用**，**隔开，**声明形参**就相当于在函数内部**声明了对应的变量**，但是**不赋值**

### 实参：

- 在**调用函数时**，可以在**()**中指定实参(实际参数)

- 实参将会**赋值**给函数中对应的形参

### 注：

- 调用函数时解析器不会检查实参的类型
- 注意是否可能接收到非法的参数，如果有可能则需要对参数进行类型的检查
- 函数的实参可以是任意的数据类型，包括对象，函数，参数过多时可将参数封装到一个对象中
- 调用函数时，解析器也不会检查实参的数量，
  - 多余实参不会被赋值，
  - 少于实参没有对应实参的形参将是 undefined

```js
// 定义一个函数（求两个数的和）
function sum(a, b) {
  console.log(a + b);
}
```

## 4.返回值

- 创建一个函数，可以用 return 来设置函数的返回值

```js
语法：
	return 值
```

- return 后的值将会作为**函数的执行结果**返回，可以**定义一个变量**，来接受结果

```js
function sum(a, b) {
  // 定义一个变量，来接受结果
  var c = a + b;
  return c;
}
var result = sum(4, 7);
console.log("result = " + result);
```

- 在函数中 return 后的语句都不会执行
- 如果 return 语句后不跟任何值就相当于返回一个 undefined
- 如果函数不写 return，则也会返回 undefined

return,break,continue 三个区别

- return 可以结束整个函数
- continue 用于跳过当次循环
- break 退出当次循环

## 5.立即执行函数

语法：

```js
(function (a, b) {
  alert("我是一个立即执行函数");
})();
```

## 6.方法

函数也可以是对象的属性，若函数作为对象的属性，则称这个函数为这个对象的方法，调用函数即调用对象的方法

```js
obj = {
  name: "何某",
  age: 18,
  address: "苏州",
  // gender是obj对象的方法
  gender: function a() {
    console.log(obj.name);
  },
};
// 调用方法
obj.gender();
```

①call()方法和 apply()方法

- 这两个方法都是函数对象的方法，需要通过函数对象来调用

- 当对函数调用 call()和 apply()都会调用函数执行

- 在调用 call()和 apply()可以将一个对象指定为第一个参数

  - 此时这个对象将成为函数执行的 this

- call()方法可以将实参在对象之后依次传递

  ```js
  fun2.call(obj, 2, 3);
  ```

- apply()方法需要将实参封装到一个数组中统一传递

  ```js
  fun2.apply(obj, [2, 3]);
  ```

this 的情况

1. 以函数形式调用时，this 永远都是 window
2. 以方法的形式调用时，this 是调用方法的对象
3. 以构造函数的形式调用时，this 是新创建的那个对象
4. 使用 call 和 apply 调用时，this 是指定的那个对象

```js
function fun() {
  alert("我是fun函数");
}
fun();

var fun2 = function () {
  alert("我是fun2函数");
};
fun2();
```

## 7.枚举对象中的属性

使用 for …in 语句

```js
语法：for(var 变量 in 对象){

}
```

- for…in 语句对象中有几个属性，循环体就会执行几次
- 每次执行时，会将对象的一个属性的名字赋值给变量

```js
for (var n in obj) {
  //枚举对象中的属性名
  console.log("属性名" + n);
  //枚举对象中的属性值
  console.log(obj[n]);
}
```

## 8.作用域

### 1.作用域：

指一个变量的作用的范围

### 2.内容：

- **全局作用域**

  - 直接编写在**script 标签中**的 JS 代码，都在全局作用域
  - 全局作用域在**页面打开时**创建，在**页面关闭时**销毁
  - 在全局作用域中有一个全局对象**window**，代表一个浏览器的窗口，由浏览器创建可直接使用
  - 在全局作用域中：
    - 创建的**变量**都会作为**window 对象的属性**保存
    - 创建的**函数**都会作为**window 对象的方法**保存
  - 全局作用域中的变量都是**全局变量**，在页面的任意部分都可以访问得到

- **函数作用域**
  - **调用函数时**创建函数作用域，**函数执行完毕**以后，函数作用域**销毁**
  - 在**函数作用域**中**可访问**到**全局作用域的变量**
    - 在**全局作用域**中**无法访问**到**函数作用域的变量**
  - 当在函数作用域操作一个变量时，他会先在**自身作用域中**寻找，如果有就直接使用
    - 如果没有则**向上一级作用域中**寻找，直到找到全局作用域，
    - 如果**全局作用域**中依然没有找到，则会报错**ReferenceError**
  - 在函数中要访问**全局变量**可以使用**window 对象**
  - 在**函数中**，**不使用 var 声明的变量**都会**成为全局变量**
  - 在**定义形参时**，就**相当于**在函数作用域中**声明了变量**

**注：**

适用于**全局作用域和函数作用域**

**变量的声明提前**

- 使用**var 关键字**声明的变量，会在**所有的代码执行之前**被声明
  - 但是如果声明变量时不使用 var 关键字，**不会被声明提前**，所以不能在声明前调用

**函数的声明提前**

- 使用函数声明形式创建的函数**function 函数(){}**
  - 他会在**所有代码执行之前**就被创建，所以我们可以在函数声明前来调用函数
- 使用**函数表达式创建**的函数，**不会被声明提前**，所以不能在声明前调用

## 9.this

- 解析器在调用函数每次都会向函数内部传递进一个隐含的参数，
  - 这个隐含的参数就是 this，this 指向的是一个**对象**
  - 这个对象我们成为**函数执行的上下文对象**
  - 根据函数的调用方式的不同，this 会指向不同的对象
    1. 以**函数**的形式调用时，this 永远都是**window**
    2. 以**方法**的形式调用时，this 就是**调用方法的那个对象**

```js
var name = "全局";
function fun() {
  document.write(this.name);
}
var obj1 = {
  name: "🐖",
  gender: "boy",
  SayName: fun,
};
var obj2 = {
  name: "🐟",
  gender: "girl",
  SayName: fun,
};
obj1.SayName();
obj2.SayName();
```

## 10.工厂化创建对象

**语法**

```js
function create(name, gender, age) {
  var obj = new Object();
  obj.name = name;
  obj.gender = gender;
  obj.age = age;
  obj.SayName = function fun() {
    console.log(this.name);
  };
  return obj;
}
obj1 = create("何", "男", 18);
obj2 = create("吴", "女", 23);
obj3 = create("李", "女", 19);
console.log(obj1);
console.log(obj2);
console.log(obj3);
```

## 11.构造函数

- 创建一个构造函数，专门用来**创建类对象**的
  - 构造函数就是一个普通的函数，创建方式和普通函数没有区别
  - 不同的是构造函数习惯上首字母大写

```js
function Person(name, age, gender) {
  this.name = name;
  this.age = age;
  this.gender = gender;
  this.SayName = function () {
    alert("Hello,大家好,我是" + this.name);
  };
}
```

- 构造函数和普通函数的区别就是**调用方式不同**

  - 普通函数是直接调用，而构造函数需要使用**new 关键字**来调用

  ```js
  var per = new Person("孙悟空",18，"男")
  ```

- 构造函数的执行流程：

  1. 立即**创建**一个**新的对象**
  2. 将**新建的对象**设置为函数中的 this，在构造函数中可以使用 this 来引用新建的对象
  3. 逐行**执行函数**中的代码
  4. 将**新建的对象作为返回值**返回

- 使用同一个构造函数创建的对象，我们称为**一类对象**，也将一个构造函数成为一个类

  - 我们将通过一个构造函数创建的对象，成为是该类的实例

- this 的情况：（**指向上一级非函数的对象**）

  1. 当以函数的形式调用时，this 就是 window
  2. 当以方法的形式调用时，谁调用方法 this 就是谁
  3. 当以构造函数的形式调用时，this 就是新创建的那个对象

- 使用 **instanceof** 可以检查一个对象是否是一个类的实例

```js
语法：
	对象 instanceof 构造函数
如果是，则返回true，否则返回false
```

- 外部定义，内部调用（省内存）

```js
function Person(name, age, gender) {
  this.name = name;
  this.age = age;
  this.gender = gender;
  this.sayName = fun;
}
function fun() {
  alert("Hello大家好，我是" + this.name);
}
```

## 12.原型（prototype）

所创建的每一个函数， 解析器都会向函数中添加一个**属性 prototype**

- 这个属性对应着一个**对象**，这个对象就是我们所谓的**原型对象**

```js
function MyClass() {}

var mc1 = new MyClass();
var mc2 = new MyClass();

MyClass.prototype.a = 123;

mc1.a = "abc";
```

**函数调用 prototype**

- 普通函数调用 prototype 没有效果
- **构造函数调用**，所创建的对象中**会有一个隐含的属性**，

  - 指向该构造函数的原型对象，我们可以通过\***\* proto\*\*** 来访问该属性

```js
document.write(mc1.__proto__.__proto__.prototype);
```

​

**原型对象**相当于一个**公共区域**，

- 所有同一个类的实例都可以访问到这个原型对象，
- 可以将对象中共有的内容，统一设置到原型对象中。

当访问对象的一个属性或方法时，先在对象自身中寻找，

- 如果**有**则**直接使用**，
- 如果**没有**则会**在原型对象**中**寻找**，如果找到则直接使

以后我们创建构造函数时，可以将这些**对象共有的属性和方法**，统一**添加到构造函数的原型对象**中，
这样**不用分别为每一个对象添加**，也**不会影响到全局作用域**，就可以使每个对象都具有这些属性和方法了

- 检查原型中的属性

  - 若使用 **in** 检查对象中是否含有某个属性时，如果对象中没有但是**原型有**，也会返回**true**

  - 可以使用对象的**hasOwnProperty()**来检查对象自身中是否含有该属性

  ```js
  document.write(mc1.__proto__.hasOwnProperty("a"));
  ```

  - 使用该方法只有当对象自身含有属性时，才会返回 true

  - 原型对象也是对象，所以也有原型,当使用一个对象的属性或方法时，会先在自身中寻找
    - 如果有，则直接使用
    - 如果没有就去原型对象中寻找，如果原型对象中有，则使用，
    - 若没有再到原型对象中的原型中寻找，知到找到 Object 对象的原型
    - Object 对象的原型没有原型，如果在 Object 的原型中仍没有找到，则返回 undefined
  - toString 的重写方法（过时）

    ```js
    Person.toString = function () {
      return (
        "Person[name=" +
        this.name +
        ",age=" +
        this.age +
        ",gender=" +
        this.gender +
        "]"
      );
    };
    ```

## 13.垃圾回收(GC)

**定义**：会对一些没有任何变量或值的对象进行回收——自动，

**做法**：需要做的为将不再使用的对象设置为 null 即可

## 14.arguments

在调用函数时，浏览器每次都会传递进两个隐含的参数

1. 函数的上下文对象 this

2. 封装实参的对象 arguments

   - arguments 时一个类数组对象，它也可以通过索引来操作数据，也可以获取长度

   - 在调用函数时，我们所传递到实参都会在 argument 是中保存

   - arguments.length 可以 i 用来获取实参的长度

   - 我们即使不定义形参，也可以通过 arguments 来使用实参，不过麻烦

     ​ arguments[0] 表示第一个实参 arguments[1] 表示第二个实参……

   - 它里边有一个属性叫做 callee，该属性对应一个函数对象，就是当前正在指向的函数的对象

     ```js
     function fun(a, b) {
       console.log(arguments[1]);
       console.log(arguments.length);
       console.log(arguments.callee);
     }
     fun("hello", true);
     ```

## 15.时间戳

Date 函数

```js
// 创建一个指定Date时间对象
var d2 = new Date("月份/日/年 时:分:秒");

// 封装当前为当前代码执行的时间
var d = new Date();

// 获得日期对象周几,会返回一个0-6的值，0为周日
getDay();
var day = d2.getDay();

// 获得日期对象月份，会返回一个0-11的值，0为1月
var month = d2.getMonth();

//获得当前日期对象的年份
var year = d2.getFullYear();

// 获得当前日期对象的时间戳
// 时间戳，指的是从格林威治时间的1970年1月1日，0时0分0秒（注意时区）
// 到当前日期所花费的毫秒数（1秒=1000毫秒）
var time = d2.getTime();

console.log(time);
```

时间戳的应用

```js
// 利用时间戳来测试代码的执行的性能
// 获取当前的时间戳
var start = Date.now();

for (var i = 0; i < 100; i++) {
  console.log(i);
}

var end = Date.now();

console.log("执行了：" + (end - start) + "毫秒");
```

# 五、数组

## 1.定义：

数组也是对象，与普通对象功能类似，用于储存值，不同的是普通对象时使用字符串作为属性名，而数组是使用数字作为索引操作元素

## 2.索引：

从 0 开始的整数

## 3.功能：

数组的存储性能比普通对象要好，在开发中我们要经常使用数组来存储一些数据

```js
var arr = new Array();
```

## 4.操作

```js
// 创建
// 第一种方法 构造函数法
var arr = new Array();
// 构造时也可以添加元素，作为构造函数的参数传递
var arr = new Array(10, 20, 30);
// 当只有一个整数元素时，即创建一个长度为10的数组
var arr = new Array(10);

//第二种方法 使用字面量来创建数组
var arr = [];
// 创建时就可以指定数组中的元素
var arr = [1, 2, 3];

// 添加
// 语法： 数组[索引] = 值
arr[0] = 10;
// 可为任意数据类型，包括对象，数组
arr = [{name:"孙悟空"}，{name:"沙和尚"}， {name:"猪八戒"} ];
// 二维数组,即数组内嵌套一个数组
arr = [[1, 2, 3], [4, 5, 6]];

// 读取
// 语法： 数组[索引] = 值
console.log(arr[0]);

// 获取数组的长度
// 可以使用length属性来获取数组的长度（元素的个数）
// 语法：数组.length
	/* 对于连续的数组，使用length可以获取到数组的长度（元素的个数），
	   对于非连续的数组，使用length会获取到数组的最大的索引+1，
	   因此尽量不要创建非连续的数组 */
console.log(arr.length);

// 修改length
	// 如果修改的length大于原长度，则多出部分会空出来
	// 如果修改的length小于原长度，则多出的元素会被删除
arr.length = 2;

// 向数组的最后一个位置添加元素
arr[arr.length] = 20;
```

## 5.方法：

①push()方法

```js
// 在数组的末尾添加一个或多个元素，并返回新长度
arr.push();
// 返回的用法
var result = arr.push(" ", " ", " ");
console.log("result = " + result);
```

②pop()方法

```js
// 删除并返回数组的最后一个元素
arr.pop();
// 返回的用法
var result = arr.pop(" ", " ", " ");
console.log("result = " + result);
```

③unshift()方法

```js
// 在数组的开头添加一个或多个元素，并返回新长度 —— 注意索引会变
arr.unshift();
// 返回的用法
var result = arr.unshift(" ", " ", " ");
console.log("result = " + result);
```

④shift()方法

```js
// 删除并返回数组的第一个元素
arr.shift();
// 返回的用法
var result = arr.shift(" ", " ", " ");
console.log("result = " + result);
```

⑤forEach()方法

```js
// 遍历数组
// forEach()方法需要一个函数作为参数
/* 采用回调函数（由我们创建但不由我们调用的函数）
   数组中有几个元素，函数就会执行几次,每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以来定义形	参，来读取这些内容 */
/* 浏览器会在回调函数中传递三个参数：
	第一个参数：元素
	第二个参数：索引
	第三个参数：数组
*/
arr.forEach(function (value, index, obj) {
  console.log(v);
});
```

⑥slice()方法

```js
// 可以从数组中提取指定元素
// 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回
/* 参数 
	1. 截取开始位置的索引，包含开始索引 
	2. 截取结束位置的索引，不包含结束索引
		-第二个参数可以省略不屑，此时会截去从开始索引往后所有元素
	-索引可以传递一个负值，如果传递一个负值，则从后往前计算
		-1 倒数第一个   -2 倒数第二个 */
// 语法 ： array.slice(start, end);
arr.slice(0, 2);
```

⑦splice()方法

```js
// 可以用于删除数组中的指定元素
// 使用splice()会影响到原数组，会将指定元素从原数组中删除，并将删除的元素作为返回值返回
/* 参数：
	1.表示开始位置的索引
	2.表示数量
	3及以后。可以传递一些新元素，插入到开始索引前 */
arr.splice(start, number, new element());
```

⑧concat()方法

```js
// concat()可以链接两个或多个数组，并将新的数组返回
//	该方法不会对原数组产生影响
arr1.concat(arr1, arr2, "xxx", "aaa");
```

⑨join()方法

```js
// 该方法可以将数组转换为一个字符串
// 该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回
// 在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符
// 	 如果不指定连接符，则默认使用，作为连接符
arr = ["xxx1", "xxx2", "xxx3"];
result = arr.join("-");
```

⑩reverse()方法

```js
// 该方法用来反转数组(前边的去后边，后边的去前边)
// 该方法会直接修改原数组
arr.reverse();
```

⑪sort()方法

```js
// 可以用来对数组中元素进行排序
// 也会影响原数组，默认会按照Unicode编码进行排序
// 即使对于纯数字的数组，使用sort()时，会按照Unicode编码来排序，所以对数字排序，可能会得到错误的结果
/* 	我们可以自己来指定排序的规则
	可在sort()添加一个回调函数，来指定排序规则
	    回调函数中需要定义两个形参，
        浏览器将会分别使用数组中的元素作为实参去调用回调函数
        使用哪个元素调用不确定，但是肯定是在数组中a一定在b前边
    浏览器会根据回调函数的返回值来决定元素的顺序
    	如果返回一个大于0的值，则元素会交换位置
    	如果返回一个小于0的值，则元素位置不变
    	如果返回一个0，则认为两个元素相等，也不交换位置
*/
arr = [5, 4];

arr.sort(function (a, b) {
  //前边的大
  if (a > b) {
    return 1;
  } else if (a < b) {
    return -1;
  } else {
    return 0;
  }
});
```

# 六、DOM

## 1.简介：

- DOM：全称 Document Object Model 文档对象模型
- JS 中通过 DOM 来对 HTML 文档进行操作，用于操作 WEB 页面
- 文档：整个 HTML 网页文档
- 对象：将网页中每个部分转换为了一个对象
- 模型：使用模型来表示对象之间的关系，以便获取对象
- 节点 Node，是构成页面最基本的元素，每个部分都可称为一个节点，
  - 分类：
    - 文档节点:整个 HTML 文档、
    - 元素节点：html 标签、
    - 属性节点：元素属性
    - 文本节点：文本内容
- 文档节点的应用：document
  - getElementById()

```js
// 获取属性节点
var btn = document.getElementById("属性值");
// 获取/修改文本内容
console.log(属性值.innerHTML);
// innerHTML用于获取元素内部的HTML代码，对于字节数标签，这个属性没有意义
```

## 2.事件

### 定义：

- 文档或浏览器窗口中发生的一些特定的交互瞬间
- JavaScript 与 HTML 之间的交互是通过实践来实现的
- 例如点击某个元素，将鼠标移动至某个元素上方，按下键盘的某个键

### 绑定事件

- 两种方法：
  - 在 html 中标签内直接写属性
  - 在 script 中获取对象后使用函数调用

### 文档加载

- body 下方，等待页面加载完后加载
- head 中，需使用 window.onload（等页面加载完事件）

## 3.获取元素节点方法

**通过 document 对象调用**

1. getElementById()
   - 通过 id 属性获取一个元素节点对象
2. getElementsByTagName()
   - 通过标签名获取一组元素节点对象
3. getElementByname()
   - 通过 name 属性获取一组元素节点对象

### 读取元素节点属性

- 直接使用元素.属性名
- value，name，type 都可以，
- 但是 class 属性不能采用这种方式，只能用 className

## 4.获取元素节点的子节点

通过具体的元素节点调用

1. getElementsByTagName()

2. childNodes -所有子节点(包含空白文本)

   children -所有子元素(不包含空白文本)

3. firstChild -第一个子节点

   firstElementChild 第一个元素(不包含空白节点)

4. lastChild -最后一个节点

## 5.获取父节点和兄弟节点

- 通过具体节点调用
  1. parentNode - 当前节点的父节点
  2. previousSibling - 当前节点的前一个兄弟节点
  3. nextSibling - 当前节点的后一个兄弟节点

## 6.dom 查询的其他方法

- document.body body 标签

- documentElement html 标签

- document.all 页面所有元素

- ### **document.querySelector()**:需要一个选择器的字符串作为参数，可以根据一个 CSS 选择器来查询一个元素节点对象

  - 使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，只会返回第一个

  ```js
  var div = document.querySelector(".box1 iv");
  ```

  - document.querySelectorAll():将所有符合条件的元素返回成数组

## 7.增删修改方法

| 方法              | 作用                                              |
| ----------------- | ------------------------------------------------- |
| appendChild()     | 把新的子节点添加到指定节点。                      |
| removeChild()     | 删除子节点。子节点.parentNode.removeChild(子节点) |
| replaceChild()    | 替换子节点。(新节点,旧节点)                       |
| insertBefore()    | 在指定的子节点前面插入新的子节点。(新节点,旧节点) |
| createAttribute() | 创建属性节点。                                    |
| createElement()   | 创建元素节点。                                    |
| createTextNode()  | 创建文本节点。                                    |
| getAttribute()    | 返回指定的属性值。                                |
| setAttribute()    | 把指定属性设置或修改为指定的值。                  |

使用 innerHTML 也可以完成 DOM 增删改的相关操作

```js
ycity.innerHTML += "<li>广州<li>";
```

8.事件对象

1. 当事件的响应函数被触发时，浏览器每次都会讲一个事件对象作为实参传递进响应函数

   - 在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标 键盘哪个按键被按下 鼠标滚轮滚动的方向
